// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router/router.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_2frouter_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_2frouter_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_2frouter_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_2frouter_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_router_2frouter_2eproto;
namespace qaul {
namespace rpc {
namespace router {
class ConnectionEntry;
struct ConnectionEntryDefaultTypeInternal;
extern ConnectionEntryDefaultTypeInternal _ConnectionEntry_default_instance_;
class ConnectionsList;
struct ConnectionsListDefaultTypeInternal;
extern ConnectionsListDefaultTypeInternal _ConnectionsList_default_instance_;
class ConnectionsRequest;
struct ConnectionsRequestDefaultTypeInternal;
extern ConnectionsRequestDefaultTypeInternal _ConnectionsRequest_default_instance_;
class ConnectionsUserEntry;
struct ConnectionsUserEntryDefaultTypeInternal;
extern ConnectionsUserEntryDefaultTypeInternal _ConnectionsUserEntry_default_instance_;
class NeighboursEntry;
struct NeighboursEntryDefaultTypeInternal;
extern NeighboursEntryDefaultTypeInternal _NeighboursEntry_default_instance_;
class NeighboursList;
struct NeighboursListDefaultTypeInternal;
extern NeighboursListDefaultTypeInternal _NeighboursList_default_instance_;
class NeighboursRequest;
struct NeighboursRequestDefaultTypeInternal;
extern NeighboursRequestDefaultTypeInternal _NeighboursRequest_default_instance_;
class Router;
struct RouterDefaultTypeInternal;
extern RouterDefaultTypeInternal _Router_default_instance_;
class RoutingTableConnection;
struct RoutingTableConnectionDefaultTypeInternal;
extern RoutingTableConnectionDefaultTypeInternal _RoutingTableConnection_default_instance_;
class RoutingTableEntry;
struct RoutingTableEntryDefaultTypeInternal;
extern RoutingTableEntryDefaultTypeInternal _RoutingTableEntry_default_instance_;
class RoutingTableList;
struct RoutingTableListDefaultTypeInternal;
extern RoutingTableListDefaultTypeInternal _RoutingTableList_default_instance_;
class RoutingTableRequest;
struct RoutingTableRequestDefaultTypeInternal;
extern RoutingTableRequestDefaultTypeInternal _RoutingTableRequest_default_instance_;
}  // namespace router
}  // namespace rpc
}  // namespace qaul
PROTOBUF_NAMESPACE_OPEN
template<> ::qaul::rpc::router::ConnectionEntry* Arena::CreateMaybeMessage<::qaul::rpc::router::ConnectionEntry>(Arena*);
template<> ::qaul::rpc::router::ConnectionsList* Arena::CreateMaybeMessage<::qaul::rpc::router::ConnectionsList>(Arena*);
template<> ::qaul::rpc::router::ConnectionsRequest* Arena::CreateMaybeMessage<::qaul::rpc::router::ConnectionsRequest>(Arena*);
template<> ::qaul::rpc::router::ConnectionsUserEntry* Arena::CreateMaybeMessage<::qaul::rpc::router::ConnectionsUserEntry>(Arena*);
template<> ::qaul::rpc::router::NeighboursEntry* Arena::CreateMaybeMessage<::qaul::rpc::router::NeighboursEntry>(Arena*);
template<> ::qaul::rpc::router::NeighboursList* Arena::CreateMaybeMessage<::qaul::rpc::router::NeighboursList>(Arena*);
template<> ::qaul::rpc::router::NeighboursRequest* Arena::CreateMaybeMessage<::qaul::rpc::router::NeighboursRequest>(Arena*);
template<> ::qaul::rpc::router::Router* Arena::CreateMaybeMessage<::qaul::rpc::router::Router>(Arena*);
template<> ::qaul::rpc::router::RoutingTableConnection* Arena::CreateMaybeMessage<::qaul::rpc::router::RoutingTableConnection>(Arena*);
template<> ::qaul::rpc::router::RoutingTableEntry* Arena::CreateMaybeMessage<::qaul::rpc::router::RoutingTableEntry>(Arena*);
template<> ::qaul::rpc::router::RoutingTableList* Arena::CreateMaybeMessage<::qaul::rpc::router::RoutingTableList>(Arena*);
template<> ::qaul::rpc::router::RoutingTableRequest* Arena::CreateMaybeMessage<::qaul::rpc::router::RoutingTableRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace qaul {
namespace rpc {
namespace router {

enum ConnectionModule : int {
  NONE = 0,
  LAN = 1,
  INTERNET = 2,
  BLE = 3,
  LOCAL = 4,
  ConnectionModule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConnectionModule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConnectionModule_IsValid(int value);
constexpr ConnectionModule ConnectionModule_MIN = NONE;
constexpr ConnectionModule ConnectionModule_MAX = LOCAL;
constexpr int ConnectionModule_ARRAYSIZE = ConnectionModule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionModule_descriptor();
template<typename T>
inline const std::string& ConnectionModule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionModule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionModule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionModule_descriptor(), enum_t_value);
}
inline bool ConnectionModule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionModule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionModule>(
    ConnectionModule_descriptor(), name, value);
}
// ===================================================================

class Router final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.Router) */ {
 public:
  inline Router() : Router(nullptr) {}
  ~Router() override;
  explicit constexpr Router(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Router(const Router& from);
  Router(Router&& from) noexcept
    : Router() {
    *this = ::std::move(from);
  }

  inline Router& operator=(const Router& from) {
    CopyFrom(from);
    return *this;
  }
  inline Router& operator=(Router&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Router& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kRoutingTableRequest = 1,
    kRoutingTable = 2,
    kConnectionsRequest = 3,
    kConnectionsList = 4,
    kNeighboursRequest = 5,
    kNeighboursList = 6,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Router* internal_default_instance() {
    return reinterpret_cast<const Router*>(
               &_Router_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Router& a, Router& b) {
    a.Swap(&b);
  }
  inline void Swap(Router* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Router* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Router* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Router>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Router& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Router& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Router* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.Router";
  }
  protected:
  explicit Router(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutingTableRequestFieldNumber = 1,
    kRoutingTableFieldNumber = 2,
    kConnectionsRequestFieldNumber = 3,
    kConnectionsListFieldNumber = 4,
    kNeighboursRequestFieldNumber = 5,
    kNeighboursListFieldNumber = 6,
  };
  // .qaul.rpc.router.RoutingTableRequest routing_table_request = 1;
  bool has_routing_table_request() const;
  private:
  bool _internal_has_routing_table_request() const;
  public:
  void clear_routing_table_request();
  const ::qaul::rpc::router::RoutingTableRequest& routing_table_request() const;
  PROTOBUF_NODISCARD ::qaul::rpc::router::RoutingTableRequest* release_routing_table_request();
  ::qaul::rpc::router::RoutingTableRequest* mutable_routing_table_request();
  void set_allocated_routing_table_request(::qaul::rpc::router::RoutingTableRequest* routing_table_request);
  private:
  const ::qaul::rpc::router::RoutingTableRequest& _internal_routing_table_request() const;
  ::qaul::rpc::router::RoutingTableRequest* _internal_mutable_routing_table_request();
  public:
  void unsafe_arena_set_allocated_routing_table_request(
      ::qaul::rpc::router::RoutingTableRequest* routing_table_request);
  ::qaul::rpc::router::RoutingTableRequest* unsafe_arena_release_routing_table_request();

  // .qaul.rpc.router.RoutingTableList routing_table = 2;
  bool has_routing_table() const;
  private:
  bool _internal_has_routing_table() const;
  public:
  void clear_routing_table();
  const ::qaul::rpc::router::RoutingTableList& routing_table() const;
  PROTOBUF_NODISCARD ::qaul::rpc::router::RoutingTableList* release_routing_table();
  ::qaul::rpc::router::RoutingTableList* mutable_routing_table();
  void set_allocated_routing_table(::qaul::rpc::router::RoutingTableList* routing_table);
  private:
  const ::qaul::rpc::router::RoutingTableList& _internal_routing_table() const;
  ::qaul::rpc::router::RoutingTableList* _internal_mutable_routing_table();
  public:
  void unsafe_arena_set_allocated_routing_table(
      ::qaul::rpc::router::RoutingTableList* routing_table);
  ::qaul::rpc::router::RoutingTableList* unsafe_arena_release_routing_table();

  // .qaul.rpc.router.ConnectionsRequest connections_request = 3;
  bool has_connections_request() const;
  private:
  bool _internal_has_connections_request() const;
  public:
  void clear_connections_request();
  const ::qaul::rpc::router::ConnectionsRequest& connections_request() const;
  PROTOBUF_NODISCARD ::qaul::rpc::router::ConnectionsRequest* release_connections_request();
  ::qaul::rpc::router::ConnectionsRequest* mutable_connections_request();
  void set_allocated_connections_request(::qaul::rpc::router::ConnectionsRequest* connections_request);
  private:
  const ::qaul::rpc::router::ConnectionsRequest& _internal_connections_request() const;
  ::qaul::rpc::router::ConnectionsRequest* _internal_mutable_connections_request();
  public:
  void unsafe_arena_set_allocated_connections_request(
      ::qaul::rpc::router::ConnectionsRequest* connections_request);
  ::qaul::rpc::router::ConnectionsRequest* unsafe_arena_release_connections_request();

  // .qaul.rpc.router.ConnectionsList connections_list = 4;
  bool has_connections_list() const;
  private:
  bool _internal_has_connections_list() const;
  public:
  void clear_connections_list();
  const ::qaul::rpc::router::ConnectionsList& connections_list() const;
  PROTOBUF_NODISCARD ::qaul::rpc::router::ConnectionsList* release_connections_list();
  ::qaul::rpc::router::ConnectionsList* mutable_connections_list();
  void set_allocated_connections_list(::qaul::rpc::router::ConnectionsList* connections_list);
  private:
  const ::qaul::rpc::router::ConnectionsList& _internal_connections_list() const;
  ::qaul::rpc::router::ConnectionsList* _internal_mutable_connections_list();
  public:
  void unsafe_arena_set_allocated_connections_list(
      ::qaul::rpc::router::ConnectionsList* connections_list);
  ::qaul::rpc::router::ConnectionsList* unsafe_arena_release_connections_list();

  // .qaul.rpc.router.NeighboursRequest neighbours_request = 5;
  bool has_neighbours_request() const;
  private:
  bool _internal_has_neighbours_request() const;
  public:
  void clear_neighbours_request();
  const ::qaul::rpc::router::NeighboursRequest& neighbours_request() const;
  PROTOBUF_NODISCARD ::qaul::rpc::router::NeighboursRequest* release_neighbours_request();
  ::qaul::rpc::router::NeighboursRequest* mutable_neighbours_request();
  void set_allocated_neighbours_request(::qaul::rpc::router::NeighboursRequest* neighbours_request);
  private:
  const ::qaul::rpc::router::NeighboursRequest& _internal_neighbours_request() const;
  ::qaul::rpc::router::NeighboursRequest* _internal_mutable_neighbours_request();
  public:
  void unsafe_arena_set_allocated_neighbours_request(
      ::qaul::rpc::router::NeighboursRequest* neighbours_request);
  ::qaul::rpc::router::NeighboursRequest* unsafe_arena_release_neighbours_request();

  // .qaul.rpc.router.NeighboursList neighbours_list = 6;
  bool has_neighbours_list() const;
  private:
  bool _internal_has_neighbours_list() const;
  public:
  void clear_neighbours_list();
  const ::qaul::rpc::router::NeighboursList& neighbours_list() const;
  PROTOBUF_NODISCARD ::qaul::rpc::router::NeighboursList* release_neighbours_list();
  ::qaul::rpc::router::NeighboursList* mutable_neighbours_list();
  void set_allocated_neighbours_list(::qaul::rpc::router::NeighboursList* neighbours_list);
  private:
  const ::qaul::rpc::router::NeighboursList& _internal_neighbours_list() const;
  ::qaul::rpc::router::NeighboursList* _internal_mutable_neighbours_list();
  public:
  void unsafe_arena_set_allocated_neighbours_list(
      ::qaul::rpc::router::NeighboursList* neighbours_list);
  ::qaul::rpc::router::NeighboursList* unsafe_arena_release_neighbours_list();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:qaul.rpc.router.Router)
 private:
  class _Internal;
  void set_has_routing_table_request();
  void set_has_routing_table();
  void set_has_connections_request();
  void set_has_connections_list();
  void set_has_neighbours_request();
  void set_has_neighbours_list();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::qaul::rpc::router::RoutingTableRequest* routing_table_request_;
    ::qaul::rpc::router::RoutingTableList* routing_table_;
    ::qaul::rpc::router::ConnectionsRequest* connections_request_;
    ::qaul::rpc::router::ConnectionsList* connections_list_;
    ::qaul::rpc::router::NeighboursRequest* neighbours_request_;
    ::qaul::rpc::router::NeighboursList* neighbours_list_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class RoutingTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:qaul.rpc.router.RoutingTableRequest) */ {
 public:
  inline RoutingTableRequest() : RoutingTableRequest(nullptr) {}
  explicit constexpr RoutingTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingTableRequest(const RoutingTableRequest& from);
  RoutingTableRequest(RoutingTableRequest&& from) noexcept
    : RoutingTableRequest() {
    *this = ::std::move(from);
  }

  inline RoutingTableRequest& operator=(const RoutingTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingTableRequest& operator=(RoutingTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingTableRequest* internal_default_instance() {
    return reinterpret_cast<const RoutingTableRequest*>(
               &_RoutingTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoutingTableRequest& a, RoutingTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RoutingTableRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RoutingTableRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.RoutingTableRequest";
  }
  protected:
  explicit RoutingTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.RoutingTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class RoutingTableList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.RoutingTableList) */ {
 public:
  inline RoutingTableList() : RoutingTableList(nullptr) {}
  ~RoutingTableList() override;
  explicit constexpr RoutingTableList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingTableList(const RoutingTableList& from);
  RoutingTableList(RoutingTableList&& from) noexcept
    : RoutingTableList() {
    *this = ::std::move(from);
  }

  inline RoutingTableList& operator=(const RoutingTableList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingTableList& operator=(RoutingTableList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingTableList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingTableList* internal_default_instance() {
    return reinterpret_cast<const RoutingTableList*>(
               &_RoutingTableList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RoutingTableList& a, RoutingTableList& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingTableList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingTableList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingTableList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingTableList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingTableList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingTableList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingTableList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.RoutingTableList";
  }
  protected:
  explicit RoutingTableList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutingTableFieldNumber = 1,
  };
  // repeated .qaul.rpc.router.RoutingTableEntry routing_table = 1;
  int routing_table_size() const;
  private:
  int _internal_routing_table_size() const;
  public:
  void clear_routing_table();
  ::qaul::rpc::router::RoutingTableEntry* mutable_routing_table(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableEntry >*
      mutable_routing_table();
  private:
  const ::qaul::rpc::router::RoutingTableEntry& _internal_routing_table(int index) const;
  ::qaul::rpc::router::RoutingTableEntry* _internal_add_routing_table();
  public:
  const ::qaul::rpc::router::RoutingTableEntry& routing_table(int index) const;
  ::qaul::rpc::router::RoutingTableEntry* add_routing_table();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableEntry >&
      routing_table() const;

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.RoutingTableList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableEntry > routing_table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class RoutingTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.RoutingTableEntry) */ {
 public:
  inline RoutingTableEntry() : RoutingTableEntry(nullptr) {}
  ~RoutingTableEntry() override;
  explicit constexpr RoutingTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingTableEntry(const RoutingTableEntry& from);
  RoutingTableEntry(RoutingTableEntry&& from) noexcept
    : RoutingTableEntry() {
    *this = ::std::move(from);
  }

  inline RoutingTableEntry& operator=(const RoutingTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingTableEntry& operator=(RoutingTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingTableEntry* internal_default_instance() {
    return reinterpret_cast<const RoutingTableEntry*>(
               &_RoutingTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoutingTableEntry& a, RoutingTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingTableEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingTableEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingTableEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.RoutingTableEntry";
  }
  protected:
  explicit RoutingTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated .qaul.rpc.router.RoutingTableConnection connections = 2;
  int connections_size() const;
  private:
  int _internal_connections_size() const;
  public:
  void clear_connections();
  ::qaul::rpc::router::RoutingTableConnection* mutable_connections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableConnection >*
      mutable_connections();
  private:
  const ::qaul::rpc::router::RoutingTableConnection& _internal_connections(int index) const;
  ::qaul::rpc::router::RoutingTableConnection* _internal_add_connections();
  public:
  const ::qaul::rpc::router::RoutingTableConnection& connections(int index) const;
  ::qaul::rpc::router::RoutingTableConnection* add_connections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableConnection >&
      connections() const;

  // bytes user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.RoutingTableEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableConnection > connections_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class RoutingTableConnection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.RoutingTableConnection) */ {
 public:
  inline RoutingTableConnection() : RoutingTableConnection(nullptr) {}
  ~RoutingTableConnection() override;
  explicit constexpr RoutingTableConnection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingTableConnection(const RoutingTableConnection& from);
  RoutingTableConnection(RoutingTableConnection&& from) noexcept
    : RoutingTableConnection() {
    *this = ::std::move(from);
  }

  inline RoutingTableConnection& operator=(const RoutingTableConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingTableConnection& operator=(RoutingTableConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingTableConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingTableConnection* internal_default_instance() {
    return reinterpret_cast<const RoutingTableConnection*>(
               &_RoutingTableConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoutingTableConnection& a, RoutingTableConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingTableConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingTableConnection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutingTableConnection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutingTableConnection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingTableConnection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingTableConnection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingTableConnection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.RoutingTableConnection";
  }
  protected:
  explicit RoutingTableConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViaFieldNumber = 4,
    kModuleFieldNumber = 2,
    kRttFieldNumber = 3,
    kHopCountFieldNumber = 5,
  };
  // bytes via = 4;
  void clear_via();
  const std::string& via() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_via(ArgT0&& arg0, ArgT... args);
  std::string* mutable_via();
  PROTOBUF_NODISCARD std::string* release_via();
  void set_allocated_via(std::string* via);
  private:
  const std::string& _internal_via() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_via(const std::string& value);
  std::string* _internal_mutable_via();
  public:

  // .qaul.rpc.router.ConnectionModule module = 2;
  void clear_module();
  ::qaul::rpc::router::ConnectionModule module() const;
  void set_module(::qaul::rpc::router::ConnectionModule value);
  private:
  ::qaul::rpc::router::ConnectionModule _internal_module() const;
  void _internal_set_module(::qaul::rpc::router::ConnectionModule value);
  public:

  // uint32 rtt = 3;
  void clear_rtt();
  uint32_t rtt() const;
  void set_rtt(uint32_t value);
  private:
  uint32_t _internal_rtt() const;
  void _internal_set_rtt(uint32_t value);
  public:

  // uint32 hop_count = 5;
  void clear_hop_count();
  uint32_t hop_count() const;
  void set_hop_count(uint32_t value);
  private:
  uint32_t _internal_hop_count() const;
  void _internal_set_hop_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.RoutingTableConnection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr via_;
  int module_;
  uint32_t rtt_;
  uint32_t hop_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class ConnectionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:qaul.rpc.router.ConnectionsRequest) */ {
 public:
  inline ConnectionsRequest() : ConnectionsRequest(nullptr) {}
  explicit constexpr ConnectionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionsRequest(const ConnectionsRequest& from);
  ConnectionsRequest(ConnectionsRequest&& from) noexcept
    : ConnectionsRequest() {
    *this = ::std::move(from);
  }

  inline ConnectionsRequest& operator=(const ConnectionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionsRequest& operator=(ConnectionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionsRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectionsRequest*>(
               &_ConnectionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConnectionsRequest& a, ConnectionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConnectionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConnectionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.ConnectionsRequest";
  }
  protected:
  explicit ConnectionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.ConnectionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class ConnectionsList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.ConnectionsList) */ {
 public:
  inline ConnectionsList() : ConnectionsList(nullptr) {}
  ~ConnectionsList() override;
  explicit constexpr ConnectionsList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionsList(const ConnectionsList& from);
  ConnectionsList(ConnectionsList&& from) noexcept
    : ConnectionsList() {
    *this = ::std::move(from);
  }

  inline ConnectionsList& operator=(const ConnectionsList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionsList& operator=(ConnectionsList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionsList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionsList* internal_default_instance() {
    return reinterpret_cast<const ConnectionsList*>(
               &_ConnectionsList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConnectionsList& a, ConnectionsList& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionsList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionsList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionsList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionsList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionsList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectionsList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionsList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.ConnectionsList";
  }
  protected:
  explicit ConnectionsList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanFieldNumber = 1,
    kInternetFieldNumber = 2,
    kBleFieldNumber = 3,
    kLocalFieldNumber = 4,
  };
  // repeated .qaul.rpc.router.ConnectionsUserEntry lan = 1;
  int lan_size() const;
  private:
  int _internal_lan_size() const;
  public:
  void clear_lan();
  ::qaul::rpc::router::ConnectionsUserEntry* mutable_lan(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
      mutable_lan();
  private:
  const ::qaul::rpc::router::ConnectionsUserEntry& _internal_lan(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* _internal_add_lan();
  public:
  const ::qaul::rpc::router::ConnectionsUserEntry& lan(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* add_lan();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
      lan() const;

  // repeated .qaul.rpc.router.ConnectionsUserEntry internet = 2;
  int internet_size() const;
  private:
  int _internal_internet_size() const;
  public:
  void clear_internet();
  ::qaul::rpc::router::ConnectionsUserEntry* mutable_internet(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
      mutable_internet();
  private:
  const ::qaul::rpc::router::ConnectionsUserEntry& _internal_internet(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* _internal_add_internet();
  public:
  const ::qaul::rpc::router::ConnectionsUserEntry& internet(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* add_internet();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
      internet() const;

  // repeated .qaul.rpc.router.ConnectionsUserEntry ble = 3;
  int ble_size() const;
  private:
  int _internal_ble_size() const;
  public:
  void clear_ble();
  ::qaul::rpc::router::ConnectionsUserEntry* mutable_ble(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
      mutable_ble();
  private:
  const ::qaul::rpc::router::ConnectionsUserEntry& _internal_ble(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* _internal_add_ble();
  public:
  const ::qaul::rpc::router::ConnectionsUserEntry& ble(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* add_ble();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
      ble() const;

  // repeated .qaul.rpc.router.ConnectionsUserEntry local = 4;
  int local_size() const;
  private:
  int _internal_local_size() const;
  public:
  void clear_local();
  ::qaul::rpc::router::ConnectionsUserEntry* mutable_local(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
      mutable_local();
  private:
  const ::qaul::rpc::router::ConnectionsUserEntry& _internal_local(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* _internal_add_local();
  public:
  const ::qaul::rpc::router::ConnectionsUserEntry& local(int index) const;
  ::qaul::rpc::router::ConnectionsUserEntry* add_local();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
      local() const;

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.ConnectionsList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry > lan_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry > internet_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry > ble_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry > local_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class ConnectionsUserEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.ConnectionsUserEntry) */ {
 public:
  inline ConnectionsUserEntry() : ConnectionsUserEntry(nullptr) {}
  ~ConnectionsUserEntry() override;
  explicit constexpr ConnectionsUserEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionsUserEntry(const ConnectionsUserEntry& from);
  ConnectionsUserEntry(ConnectionsUserEntry&& from) noexcept
    : ConnectionsUserEntry() {
    *this = ::std::move(from);
  }

  inline ConnectionsUserEntry& operator=(const ConnectionsUserEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionsUserEntry& operator=(ConnectionsUserEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionsUserEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionsUserEntry* internal_default_instance() {
    return reinterpret_cast<const ConnectionsUserEntry*>(
               &_ConnectionsUserEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ConnectionsUserEntry& a, ConnectionsUserEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionsUserEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionsUserEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionsUserEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionsUserEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionsUserEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectionsUserEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionsUserEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.ConnectionsUserEntry";
  }
  protected:
  explicit ConnectionsUserEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated .qaul.rpc.router.ConnectionEntry connections = 2;
  int connections_size() const;
  private:
  int _internal_connections_size() const;
  public:
  void clear_connections();
  ::qaul::rpc::router::ConnectionEntry* mutable_connections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionEntry >*
      mutable_connections();
  private:
  const ::qaul::rpc::router::ConnectionEntry& _internal_connections(int index) const;
  ::qaul::rpc::router::ConnectionEntry* _internal_add_connections();
  public:
  const ::qaul::rpc::router::ConnectionEntry& connections(int index) const;
  ::qaul::rpc::router::ConnectionEntry* add_connections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionEntry >&
      connections() const;

  // bytes user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.ConnectionsUserEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionEntry > connections_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class ConnectionEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.ConnectionEntry) */ {
 public:
  inline ConnectionEntry() : ConnectionEntry(nullptr) {}
  ~ConnectionEntry() override;
  explicit constexpr ConnectionEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionEntry(const ConnectionEntry& from);
  ConnectionEntry(ConnectionEntry&& from) noexcept
    : ConnectionEntry() {
    *this = ::std::move(from);
  }

  inline ConnectionEntry& operator=(const ConnectionEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionEntry& operator=(ConnectionEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionEntry* internal_default_instance() {
    return reinterpret_cast<const ConnectionEntry*>(
               &_ConnectionEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ConnectionEntry& a, ConnectionEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConnectionEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.ConnectionEntry";
  }
  protected:
  explicit ConnectionEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViaFieldNumber = 3,
    kRttFieldNumber = 1,
    kHopCountFieldNumber = 2,
  };
  // bytes via = 3;
  void clear_via();
  const std::string& via() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_via(ArgT0&& arg0, ArgT... args);
  std::string* mutable_via();
  PROTOBUF_NODISCARD std::string* release_via();
  void set_allocated_via(std::string* via);
  private:
  const std::string& _internal_via() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_via(const std::string& value);
  std::string* _internal_mutable_via();
  public:

  // uint32 rtt = 1;
  void clear_rtt();
  uint32_t rtt() const;
  void set_rtt(uint32_t value);
  private:
  uint32_t _internal_rtt() const;
  void _internal_set_rtt(uint32_t value);
  public:

  // uint32 hop_count = 2;
  void clear_hop_count();
  uint32_t hop_count() const;
  void set_hop_count(uint32_t value);
  private:
  uint32_t _internal_hop_count() const;
  void _internal_set_hop_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.ConnectionEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr via_;
  uint32_t rtt_;
  uint32_t hop_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class NeighboursRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:qaul.rpc.router.NeighboursRequest) */ {
 public:
  inline NeighboursRequest() : NeighboursRequest(nullptr) {}
  explicit constexpr NeighboursRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NeighboursRequest(const NeighboursRequest& from);
  NeighboursRequest(NeighboursRequest&& from) noexcept
    : NeighboursRequest() {
    *this = ::std::move(from);
  }

  inline NeighboursRequest& operator=(const NeighboursRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeighboursRequest& operator=(NeighboursRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeighboursRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeighboursRequest* internal_default_instance() {
    return reinterpret_cast<const NeighboursRequest*>(
               &_NeighboursRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NeighboursRequest& a, NeighboursRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NeighboursRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeighboursRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeighboursRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeighboursRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NeighboursRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NeighboursRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.NeighboursRequest";
  }
  protected:
  explicit NeighboursRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.NeighboursRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class NeighboursList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.NeighboursList) */ {
 public:
  inline NeighboursList() : NeighboursList(nullptr) {}
  ~NeighboursList() override;
  explicit constexpr NeighboursList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NeighboursList(const NeighboursList& from);
  NeighboursList(NeighboursList&& from) noexcept
    : NeighboursList() {
    *this = ::std::move(from);
  }

  inline NeighboursList& operator=(const NeighboursList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeighboursList& operator=(NeighboursList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeighboursList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeighboursList* internal_default_instance() {
    return reinterpret_cast<const NeighboursList*>(
               &_NeighboursList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NeighboursList& a, NeighboursList& b) {
    a.Swap(&b);
  }
  inline void Swap(NeighboursList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeighboursList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeighboursList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeighboursList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NeighboursList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NeighboursList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NeighboursList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.NeighboursList";
  }
  protected:
  explicit NeighboursList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanFieldNumber = 1,
    kInternetFieldNumber = 2,
  };
  // repeated .qaul.rpc.router.NeighboursEntry lan = 1;
  int lan_size() const;
  private:
  int _internal_lan_size() const;
  public:
  void clear_lan();
  ::qaul::rpc::router::NeighboursEntry* mutable_lan(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >*
      mutable_lan();
  private:
  const ::qaul::rpc::router::NeighboursEntry& _internal_lan(int index) const;
  ::qaul::rpc::router::NeighboursEntry* _internal_add_lan();
  public:
  const ::qaul::rpc::router::NeighboursEntry& lan(int index) const;
  ::qaul::rpc::router::NeighboursEntry* add_lan();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >&
      lan() const;

  // repeated .qaul.rpc.router.NeighboursEntry internet = 2;
  int internet_size() const;
  private:
  int _internal_internet_size() const;
  public:
  void clear_internet();
  ::qaul::rpc::router::NeighboursEntry* mutable_internet(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >*
      mutable_internet();
  private:
  const ::qaul::rpc::router::NeighboursEntry& _internal_internet(int index) const;
  ::qaul::rpc::router::NeighboursEntry* _internal_add_internet();
  public:
  const ::qaul::rpc::router::NeighboursEntry& internet(int index) const;
  ::qaul::rpc::router::NeighboursEntry* add_internet();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >&
      internet() const;

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.NeighboursList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry > lan_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry > internet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// -------------------------------------------------------------------

class NeighboursEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:qaul.rpc.router.NeighboursEntry) */ {
 public:
  inline NeighboursEntry() : NeighboursEntry(nullptr) {}
  ~NeighboursEntry() override;
  explicit constexpr NeighboursEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NeighboursEntry(const NeighboursEntry& from);
  NeighboursEntry(NeighboursEntry&& from) noexcept
    : NeighboursEntry() {
    *this = ::std::move(from);
  }

  inline NeighboursEntry& operator=(const NeighboursEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeighboursEntry& operator=(NeighboursEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NeighboursEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const NeighboursEntry* internal_default_instance() {
    return reinterpret_cast<const NeighboursEntry*>(
               &_NeighboursEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NeighboursEntry& a, NeighboursEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(NeighboursEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeighboursEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NeighboursEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NeighboursEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NeighboursEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NeighboursEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NeighboursEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "qaul.rpc.router.NeighboursEntry";
  }
  protected:
  explicit NeighboursEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kRttFieldNumber = 2,
  };
  // bytes node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // uint32 rtt = 2;
  void clear_rtt();
  uint32_t rtt() const;
  void set_rtt(uint32_t value);
  private:
  uint32_t _internal_rtt() const;
  void _internal_set_rtt(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:qaul.rpc.router.NeighboursEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  uint32_t rtt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2frouter_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Router

// .qaul.rpc.router.RoutingTableRequest routing_table_request = 1;
inline bool Router::_internal_has_routing_table_request() const {
  return message_case() == kRoutingTableRequest;
}
inline bool Router::has_routing_table_request() const {
  return _internal_has_routing_table_request();
}
inline void Router::set_has_routing_table_request() {
  _oneof_case_[0] = kRoutingTableRequest;
}
inline void Router::clear_routing_table_request() {
  if (_internal_has_routing_table_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.routing_table_request_;
    }
    clear_has_message();
  }
}
inline ::qaul::rpc::router::RoutingTableRequest* Router::release_routing_table_request() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.Router.routing_table_request)
  if (_internal_has_routing_table_request()) {
    clear_has_message();
      ::qaul::rpc::router::RoutingTableRequest* temp = message_.routing_table_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.routing_table_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::rpc::router::RoutingTableRequest& Router::_internal_routing_table_request() const {
  return _internal_has_routing_table_request()
      ? *message_.routing_table_request_
      : reinterpret_cast< ::qaul::rpc::router::RoutingTableRequest&>(::qaul::rpc::router::_RoutingTableRequest_default_instance_);
}
inline const ::qaul::rpc::router::RoutingTableRequest& Router::routing_table_request() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.Router.routing_table_request)
  return _internal_routing_table_request();
}
inline ::qaul::rpc::router::RoutingTableRequest* Router::unsafe_arena_release_routing_table_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.rpc.router.Router.routing_table_request)
  if (_internal_has_routing_table_request()) {
    clear_has_message();
    ::qaul::rpc::router::RoutingTableRequest* temp = message_.routing_table_request_;
    message_.routing_table_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Router::unsafe_arena_set_allocated_routing_table_request(::qaul::rpc::router::RoutingTableRequest* routing_table_request) {
  clear_message();
  if (routing_table_request) {
    set_has_routing_table_request();
    message_.routing_table_request_ = routing_table_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.rpc.router.Router.routing_table_request)
}
inline ::qaul::rpc::router::RoutingTableRequest* Router::_internal_mutable_routing_table_request() {
  if (!_internal_has_routing_table_request()) {
    clear_message();
    set_has_routing_table_request();
    message_.routing_table_request_ = CreateMaybeMessage< ::qaul::rpc::router::RoutingTableRequest >(GetArenaForAllocation());
  }
  return message_.routing_table_request_;
}
inline ::qaul::rpc::router::RoutingTableRequest* Router::mutable_routing_table_request() {
  ::qaul::rpc::router::RoutingTableRequest* _msg = _internal_mutable_routing_table_request();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.Router.routing_table_request)
  return _msg;
}

// .qaul.rpc.router.RoutingTableList routing_table = 2;
inline bool Router::_internal_has_routing_table() const {
  return message_case() == kRoutingTable;
}
inline bool Router::has_routing_table() const {
  return _internal_has_routing_table();
}
inline void Router::set_has_routing_table() {
  _oneof_case_[0] = kRoutingTable;
}
inline void Router::clear_routing_table() {
  if (_internal_has_routing_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.routing_table_;
    }
    clear_has_message();
  }
}
inline ::qaul::rpc::router::RoutingTableList* Router::release_routing_table() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.Router.routing_table)
  if (_internal_has_routing_table()) {
    clear_has_message();
      ::qaul::rpc::router::RoutingTableList* temp = message_.routing_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.routing_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::rpc::router::RoutingTableList& Router::_internal_routing_table() const {
  return _internal_has_routing_table()
      ? *message_.routing_table_
      : reinterpret_cast< ::qaul::rpc::router::RoutingTableList&>(::qaul::rpc::router::_RoutingTableList_default_instance_);
}
inline const ::qaul::rpc::router::RoutingTableList& Router::routing_table() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.Router.routing_table)
  return _internal_routing_table();
}
inline ::qaul::rpc::router::RoutingTableList* Router::unsafe_arena_release_routing_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.rpc.router.Router.routing_table)
  if (_internal_has_routing_table()) {
    clear_has_message();
    ::qaul::rpc::router::RoutingTableList* temp = message_.routing_table_;
    message_.routing_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Router::unsafe_arena_set_allocated_routing_table(::qaul::rpc::router::RoutingTableList* routing_table) {
  clear_message();
  if (routing_table) {
    set_has_routing_table();
    message_.routing_table_ = routing_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.rpc.router.Router.routing_table)
}
inline ::qaul::rpc::router::RoutingTableList* Router::_internal_mutable_routing_table() {
  if (!_internal_has_routing_table()) {
    clear_message();
    set_has_routing_table();
    message_.routing_table_ = CreateMaybeMessage< ::qaul::rpc::router::RoutingTableList >(GetArenaForAllocation());
  }
  return message_.routing_table_;
}
inline ::qaul::rpc::router::RoutingTableList* Router::mutable_routing_table() {
  ::qaul::rpc::router::RoutingTableList* _msg = _internal_mutable_routing_table();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.Router.routing_table)
  return _msg;
}

// .qaul.rpc.router.ConnectionsRequest connections_request = 3;
inline bool Router::_internal_has_connections_request() const {
  return message_case() == kConnectionsRequest;
}
inline bool Router::has_connections_request() const {
  return _internal_has_connections_request();
}
inline void Router::set_has_connections_request() {
  _oneof_case_[0] = kConnectionsRequest;
}
inline void Router::clear_connections_request() {
  if (_internal_has_connections_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.connections_request_;
    }
    clear_has_message();
  }
}
inline ::qaul::rpc::router::ConnectionsRequest* Router::release_connections_request() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.Router.connections_request)
  if (_internal_has_connections_request()) {
    clear_has_message();
      ::qaul::rpc::router::ConnectionsRequest* temp = message_.connections_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.connections_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::rpc::router::ConnectionsRequest& Router::_internal_connections_request() const {
  return _internal_has_connections_request()
      ? *message_.connections_request_
      : reinterpret_cast< ::qaul::rpc::router::ConnectionsRequest&>(::qaul::rpc::router::_ConnectionsRequest_default_instance_);
}
inline const ::qaul::rpc::router::ConnectionsRequest& Router::connections_request() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.Router.connections_request)
  return _internal_connections_request();
}
inline ::qaul::rpc::router::ConnectionsRequest* Router::unsafe_arena_release_connections_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.rpc.router.Router.connections_request)
  if (_internal_has_connections_request()) {
    clear_has_message();
    ::qaul::rpc::router::ConnectionsRequest* temp = message_.connections_request_;
    message_.connections_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Router::unsafe_arena_set_allocated_connections_request(::qaul::rpc::router::ConnectionsRequest* connections_request) {
  clear_message();
  if (connections_request) {
    set_has_connections_request();
    message_.connections_request_ = connections_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.rpc.router.Router.connections_request)
}
inline ::qaul::rpc::router::ConnectionsRequest* Router::_internal_mutable_connections_request() {
  if (!_internal_has_connections_request()) {
    clear_message();
    set_has_connections_request();
    message_.connections_request_ = CreateMaybeMessage< ::qaul::rpc::router::ConnectionsRequest >(GetArenaForAllocation());
  }
  return message_.connections_request_;
}
inline ::qaul::rpc::router::ConnectionsRequest* Router::mutable_connections_request() {
  ::qaul::rpc::router::ConnectionsRequest* _msg = _internal_mutable_connections_request();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.Router.connections_request)
  return _msg;
}

// .qaul.rpc.router.ConnectionsList connections_list = 4;
inline bool Router::_internal_has_connections_list() const {
  return message_case() == kConnectionsList;
}
inline bool Router::has_connections_list() const {
  return _internal_has_connections_list();
}
inline void Router::set_has_connections_list() {
  _oneof_case_[0] = kConnectionsList;
}
inline void Router::clear_connections_list() {
  if (_internal_has_connections_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.connections_list_;
    }
    clear_has_message();
  }
}
inline ::qaul::rpc::router::ConnectionsList* Router::release_connections_list() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.Router.connections_list)
  if (_internal_has_connections_list()) {
    clear_has_message();
      ::qaul::rpc::router::ConnectionsList* temp = message_.connections_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.connections_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::rpc::router::ConnectionsList& Router::_internal_connections_list() const {
  return _internal_has_connections_list()
      ? *message_.connections_list_
      : reinterpret_cast< ::qaul::rpc::router::ConnectionsList&>(::qaul::rpc::router::_ConnectionsList_default_instance_);
}
inline const ::qaul::rpc::router::ConnectionsList& Router::connections_list() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.Router.connections_list)
  return _internal_connections_list();
}
inline ::qaul::rpc::router::ConnectionsList* Router::unsafe_arena_release_connections_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.rpc.router.Router.connections_list)
  if (_internal_has_connections_list()) {
    clear_has_message();
    ::qaul::rpc::router::ConnectionsList* temp = message_.connections_list_;
    message_.connections_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Router::unsafe_arena_set_allocated_connections_list(::qaul::rpc::router::ConnectionsList* connections_list) {
  clear_message();
  if (connections_list) {
    set_has_connections_list();
    message_.connections_list_ = connections_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.rpc.router.Router.connections_list)
}
inline ::qaul::rpc::router::ConnectionsList* Router::_internal_mutable_connections_list() {
  if (!_internal_has_connections_list()) {
    clear_message();
    set_has_connections_list();
    message_.connections_list_ = CreateMaybeMessage< ::qaul::rpc::router::ConnectionsList >(GetArenaForAllocation());
  }
  return message_.connections_list_;
}
inline ::qaul::rpc::router::ConnectionsList* Router::mutable_connections_list() {
  ::qaul::rpc::router::ConnectionsList* _msg = _internal_mutable_connections_list();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.Router.connections_list)
  return _msg;
}

// .qaul.rpc.router.NeighboursRequest neighbours_request = 5;
inline bool Router::_internal_has_neighbours_request() const {
  return message_case() == kNeighboursRequest;
}
inline bool Router::has_neighbours_request() const {
  return _internal_has_neighbours_request();
}
inline void Router::set_has_neighbours_request() {
  _oneof_case_[0] = kNeighboursRequest;
}
inline void Router::clear_neighbours_request() {
  if (_internal_has_neighbours_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.neighbours_request_;
    }
    clear_has_message();
  }
}
inline ::qaul::rpc::router::NeighboursRequest* Router::release_neighbours_request() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.Router.neighbours_request)
  if (_internal_has_neighbours_request()) {
    clear_has_message();
      ::qaul::rpc::router::NeighboursRequest* temp = message_.neighbours_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.neighbours_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::rpc::router::NeighboursRequest& Router::_internal_neighbours_request() const {
  return _internal_has_neighbours_request()
      ? *message_.neighbours_request_
      : reinterpret_cast< ::qaul::rpc::router::NeighboursRequest&>(::qaul::rpc::router::_NeighboursRequest_default_instance_);
}
inline const ::qaul::rpc::router::NeighboursRequest& Router::neighbours_request() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.Router.neighbours_request)
  return _internal_neighbours_request();
}
inline ::qaul::rpc::router::NeighboursRequest* Router::unsafe_arena_release_neighbours_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.rpc.router.Router.neighbours_request)
  if (_internal_has_neighbours_request()) {
    clear_has_message();
    ::qaul::rpc::router::NeighboursRequest* temp = message_.neighbours_request_;
    message_.neighbours_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Router::unsafe_arena_set_allocated_neighbours_request(::qaul::rpc::router::NeighboursRequest* neighbours_request) {
  clear_message();
  if (neighbours_request) {
    set_has_neighbours_request();
    message_.neighbours_request_ = neighbours_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.rpc.router.Router.neighbours_request)
}
inline ::qaul::rpc::router::NeighboursRequest* Router::_internal_mutable_neighbours_request() {
  if (!_internal_has_neighbours_request()) {
    clear_message();
    set_has_neighbours_request();
    message_.neighbours_request_ = CreateMaybeMessage< ::qaul::rpc::router::NeighboursRequest >(GetArenaForAllocation());
  }
  return message_.neighbours_request_;
}
inline ::qaul::rpc::router::NeighboursRequest* Router::mutable_neighbours_request() {
  ::qaul::rpc::router::NeighboursRequest* _msg = _internal_mutable_neighbours_request();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.Router.neighbours_request)
  return _msg;
}

// .qaul.rpc.router.NeighboursList neighbours_list = 6;
inline bool Router::_internal_has_neighbours_list() const {
  return message_case() == kNeighboursList;
}
inline bool Router::has_neighbours_list() const {
  return _internal_has_neighbours_list();
}
inline void Router::set_has_neighbours_list() {
  _oneof_case_[0] = kNeighboursList;
}
inline void Router::clear_neighbours_list() {
  if (_internal_has_neighbours_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.neighbours_list_;
    }
    clear_has_message();
  }
}
inline ::qaul::rpc::router::NeighboursList* Router::release_neighbours_list() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.Router.neighbours_list)
  if (_internal_has_neighbours_list()) {
    clear_has_message();
      ::qaul::rpc::router::NeighboursList* temp = message_.neighbours_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.neighbours_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::qaul::rpc::router::NeighboursList& Router::_internal_neighbours_list() const {
  return _internal_has_neighbours_list()
      ? *message_.neighbours_list_
      : reinterpret_cast< ::qaul::rpc::router::NeighboursList&>(::qaul::rpc::router::_NeighboursList_default_instance_);
}
inline const ::qaul::rpc::router::NeighboursList& Router::neighbours_list() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.Router.neighbours_list)
  return _internal_neighbours_list();
}
inline ::qaul::rpc::router::NeighboursList* Router::unsafe_arena_release_neighbours_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:qaul.rpc.router.Router.neighbours_list)
  if (_internal_has_neighbours_list()) {
    clear_has_message();
    ::qaul::rpc::router::NeighboursList* temp = message_.neighbours_list_;
    message_.neighbours_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Router::unsafe_arena_set_allocated_neighbours_list(::qaul::rpc::router::NeighboursList* neighbours_list) {
  clear_message();
  if (neighbours_list) {
    set_has_neighbours_list();
    message_.neighbours_list_ = neighbours_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:qaul.rpc.router.Router.neighbours_list)
}
inline ::qaul::rpc::router::NeighboursList* Router::_internal_mutable_neighbours_list() {
  if (!_internal_has_neighbours_list()) {
    clear_message();
    set_has_neighbours_list();
    message_.neighbours_list_ = CreateMaybeMessage< ::qaul::rpc::router::NeighboursList >(GetArenaForAllocation());
  }
  return message_.neighbours_list_;
}
inline ::qaul::rpc::router::NeighboursList* Router::mutable_neighbours_list() {
  ::qaul::rpc::router::NeighboursList* _msg = _internal_mutable_neighbours_list();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.Router.neighbours_list)
  return _msg;
}

inline bool Router::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Router::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Router::MessageCase Router::message_case() const {
  return Router::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoutingTableRequest

// -------------------------------------------------------------------

// RoutingTableList

// repeated .qaul.rpc.router.RoutingTableEntry routing_table = 1;
inline int RoutingTableList::_internal_routing_table_size() const {
  return routing_table_.size();
}
inline int RoutingTableList::routing_table_size() const {
  return _internal_routing_table_size();
}
inline void RoutingTableList::clear_routing_table() {
  routing_table_.Clear();
}
inline ::qaul::rpc::router::RoutingTableEntry* RoutingTableList::mutable_routing_table(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.RoutingTableList.routing_table)
  return routing_table_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableEntry >*
RoutingTableList::mutable_routing_table() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.RoutingTableList.routing_table)
  return &routing_table_;
}
inline const ::qaul::rpc::router::RoutingTableEntry& RoutingTableList::_internal_routing_table(int index) const {
  return routing_table_.Get(index);
}
inline const ::qaul::rpc::router::RoutingTableEntry& RoutingTableList::routing_table(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.RoutingTableList.routing_table)
  return _internal_routing_table(index);
}
inline ::qaul::rpc::router::RoutingTableEntry* RoutingTableList::_internal_add_routing_table() {
  return routing_table_.Add();
}
inline ::qaul::rpc::router::RoutingTableEntry* RoutingTableList::add_routing_table() {
  ::qaul::rpc::router::RoutingTableEntry* _add = _internal_add_routing_table();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.RoutingTableList.routing_table)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableEntry >&
RoutingTableList::routing_table() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.RoutingTableList.routing_table)
  return routing_table_;
}

// -------------------------------------------------------------------

// RoutingTableEntry

// bytes user_id = 1;
inline void RoutingTableEntry::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& RoutingTableEntry::user_id() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.RoutingTableEntry.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoutingTableEntry::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.rpc.router.RoutingTableEntry.user_id)
}
inline std::string* RoutingTableEntry::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.RoutingTableEntry.user_id)
  return _s;
}
inline const std::string& RoutingTableEntry::_internal_user_id() const {
  return user_id_.Get();
}
inline void RoutingTableEntry::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoutingTableEntry::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoutingTableEntry::release_user_id() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.RoutingTableEntry.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoutingTableEntry::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.rpc.router.RoutingTableEntry.user_id)
}

// repeated .qaul.rpc.router.RoutingTableConnection connections = 2;
inline int RoutingTableEntry::_internal_connections_size() const {
  return connections_.size();
}
inline int RoutingTableEntry::connections_size() const {
  return _internal_connections_size();
}
inline void RoutingTableEntry::clear_connections() {
  connections_.Clear();
}
inline ::qaul::rpc::router::RoutingTableConnection* RoutingTableEntry::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.RoutingTableEntry.connections)
  return connections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableConnection >*
RoutingTableEntry::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.RoutingTableEntry.connections)
  return &connections_;
}
inline const ::qaul::rpc::router::RoutingTableConnection& RoutingTableEntry::_internal_connections(int index) const {
  return connections_.Get(index);
}
inline const ::qaul::rpc::router::RoutingTableConnection& RoutingTableEntry::connections(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.RoutingTableEntry.connections)
  return _internal_connections(index);
}
inline ::qaul::rpc::router::RoutingTableConnection* RoutingTableEntry::_internal_add_connections() {
  return connections_.Add();
}
inline ::qaul::rpc::router::RoutingTableConnection* RoutingTableEntry::add_connections() {
  ::qaul::rpc::router::RoutingTableConnection* _add = _internal_add_connections();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.RoutingTableEntry.connections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::RoutingTableConnection >&
RoutingTableEntry::connections() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.RoutingTableEntry.connections)
  return connections_;
}

// -------------------------------------------------------------------

// RoutingTableConnection

// .qaul.rpc.router.ConnectionModule module = 2;
inline void RoutingTableConnection::clear_module() {
  module_ = 0;
}
inline ::qaul::rpc::router::ConnectionModule RoutingTableConnection::_internal_module() const {
  return static_cast< ::qaul::rpc::router::ConnectionModule >(module_);
}
inline ::qaul::rpc::router::ConnectionModule RoutingTableConnection::module() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.RoutingTableConnection.module)
  return _internal_module();
}
inline void RoutingTableConnection::_internal_set_module(::qaul::rpc::router::ConnectionModule value) {
  
  module_ = value;
}
inline void RoutingTableConnection::set_module(::qaul::rpc::router::ConnectionModule value) {
  _internal_set_module(value);
  // @@protoc_insertion_point(field_set:qaul.rpc.router.RoutingTableConnection.module)
}

// uint32 rtt = 3;
inline void RoutingTableConnection::clear_rtt() {
  rtt_ = 0u;
}
inline uint32_t RoutingTableConnection::_internal_rtt() const {
  return rtt_;
}
inline uint32_t RoutingTableConnection::rtt() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.RoutingTableConnection.rtt)
  return _internal_rtt();
}
inline void RoutingTableConnection::_internal_set_rtt(uint32_t value) {
  
  rtt_ = value;
}
inline void RoutingTableConnection::set_rtt(uint32_t value) {
  _internal_set_rtt(value);
  // @@protoc_insertion_point(field_set:qaul.rpc.router.RoutingTableConnection.rtt)
}

// uint32 hop_count = 5;
inline void RoutingTableConnection::clear_hop_count() {
  hop_count_ = 0u;
}
inline uint32_t RoutingTableConnection::_internal_hop_count() const {
  return hop_count_;
}
inline uint32_t RoutingTableConnection::hop_count() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.RoutingTableConnection.hop_count)
  return _internal_hop_count();
}
inline void RoutingTableConnection::_internal_set_hop_count(uint32_t value) {
  
  hop_count_ = value;
}
inline void RoutingTableConnection::set_hop_count(uint32_t value) {
  _internal_set_hop_count(value);
  // @@protoc_insertion_point(field_set:qaul.rpc.router.RoutingTableConnection.hop_count)
}

// bytes via = 4;
inline void RoutingTableConnection::clear_via() {
  via_.ClearToEmpty();
}
inline const std::string& RoutingTableConnection::via() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.RoutingTableConnection.via)
  return _internal_via();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoutingTableConnection::set_via(ArgT0&& arg0, ArgT... args) {
 
 via_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.rpc.router.RoutingTableConnection.via)
}
inline std::string* RoutingTableConnection::mutable_via() {
  std::string* _s = _internal_mutable_via();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.RoutingTableConnection.via)
  return _s;
}
inline const std::string& RoutingTableConnection::_internal_via() const {
  return via_.Get();
}
inline void RoutingTableConnection::_internal_set_via(const std::string& value) {
  
  via_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoutingTableConnection::_internal_mutable_via() {
  
  return via_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoutingTableConnection::release_via() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.RoutingTableConnection.via)
  return via_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoutingTableConnection::set_allocated_via(std::string* via) {
  if (via != nullptr) {
    
  } else {
    
  }
  via_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), via,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (via_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    via_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.rpc.router.RoutingTableConnection.via)
}

// -------------------------------------------------------------------

// ConnectionsRequest

// -------------------------------------------------------------------

// ConnectionsList

// repeated .qaul.rpc.router.ConnectionsUserEntry lan = 1;
inline int ConnectionsList::_internal_lan_size() const {
  return lan_.size();
}
inline int ConnectionsList::lan_size() const {
  return _internal_lan_size();
}
inline void ConnectionsList::clear_lan() {
  lan_.Clear();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::mutable_lan(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.ConnectionsList.lan)
  return lan_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
ConnectionsList::mutable_lan() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.ConnectionsList.lan)
  return &lan_;
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::_internal_lan(int index) const {
  return lan_.Get(index);
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::lan(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionsList.lan)
  return _internal_lan(index);
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::_internal_add_lan() {
  return lan_.Add();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::add_lan() {
  ::qaul::rpc::router::ConnectionsUserEntry* _add = _internal_add_lan();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.ConnectionsList.lan)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
ConnectionsList::lan() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.ConnectionsList.lan)
  return lan_;
}

// repeated .qaul.rpc.router.ConnectionsUserEntry internet = 2;
inline int ConnectionsList::_internal_internet_size() const {
  return internet_.size();
}
inline int ConnectionsList::internet_size() const {
  return _internal_internet_size();
}
inline void ConnectionsList::clear_internet() {
  internet_.Clear();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::mutable_internet(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.ConnectionsList.internet)
  return internet_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
ConnectionsList::mutable_internet() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.ConnectionsList.internet)
  return &internet_;
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::_internal_internet(int index) const {
  return internet_.Get(index);
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::internet(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionsList.internet)
  return _internal_internet(index);
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::_internal_add_internet() {
  return internet_.Add();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::add_internet() {
  ::qaul::rpc::router::ConnectionsUserEntry* _add = _internal_add_internet();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.ConnectionsList.internet)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
ConnectionsList::internet() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.ConnectionsList.internet)
  return internet_;
}

// repeated .qaul.rpc.router.ConnectionsUserEntry ble = 3;
inline int ConnectionsList::_internal_ble_size() const {
  return ble_.size();
}
inline int ConnectionsList::ble_size() const {
  return _internal_ble_size();
}
inline void ConnectionsList::clear_ble() {
  ble_.Clear();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::mutable_ble(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.ConnectionsList.ble)
  return ble_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
ConnectionsList::mutable_ble() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.ConnectionsList.ble)
  return &ble_;
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::_internal_ble(int index) const {
  return ble_.Get(index);
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::ble(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionsList.ble)
  return _internal_ble(index);
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::_internal_add_ble() {
  return ble_.Add();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::add_ble() {
  ::qaul::rpc::router::ConnectionsUserEntry* _add = _internal_add_ble();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.ConnectionsList.ble)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
ConnectionsList::ble() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.ConnectionsList.ble)
  return ble_;
}

// repeated .qaul.rpc.router.ConnectionsUserEntry local = 4;
inline int ConnectionsList::_internal_local_size() const {
  return local_.size();
}
inline int ConnectionsList::local_size() const {
  return _internal_local_size();
}
inline void ConnectionsList::clear_local() {
  local_.Clear();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::mutable_local(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.ConnectionsList.local)
  return local_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >*
ConnectionsList::mutable_local() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.ConnectionsList.local)
  return &local_;
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::_internal_local(int index) const {
  return local_.Get(index);
}
inline const ::qaul::rpc::router::ConnectionsUserEntry& ConnectionsList::local(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionsList.local)
  return _internal_local(index);
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::_internal_add_local() {
  return local_.Add();
}
inline ::qaul::rpc::router::ConnectionsUserEntry* ConnectionsList::add_local() {
  ::qaul::rpc::router::ConnectionsUserEntry* _add = _internal_add_local();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.ConnectionsList.local)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionsUserEntry >&
ConnectionsList::local() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.ConnectionsList.local)
  return local_;
}

// -------------------------------------------------------------------

// ConnectionsUserEntry

// bytes user_id = 1;
inline void ConnectionsUserEntry::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ConnectionsUserEntry::user_id() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionsUserEntry.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionsUserEntry::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.rpc.router.ConnectionsUserEntry.user_id)
}
inline std::string* ConnectionsUserEntry::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.ConnectionsUserEntry.user_id)
  return _s;
}
inline const std::string& ConnectionsUserEntry::_internal_user_id() const {
  return user_id_.Get();
}
inline void ConnectionsUserEntry::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionsUserEntry::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionsUserEntry::release_user_id() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.ConnectionsUserEntry.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConnectionsUserEntry::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.rpc.router.ConnectionsUserEntry.user_id)
}

// repeated .qaul.rpc.router.ConnectionEntry connections = 2;
inline int ConnectionsUserEntry::_internal_connections_size() const {
  return connections_.size();
}
inline int ConnectionsUserEntry::connections_size() const {
  return _internal_connections_size();
}
inline void ConnectionsUserEntry::clear_connections() {
  connections_.Clear();
}
inline ::qaul::rpc::router::ConnectionEntry* ConnectionsUserEntry::mutable_connections(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.ConnectionsUserEntry.connections)
  return connections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionEntry >*
ConnectionsUserEntry::mutable_connections() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.ConnectionsUserEntry.connections)
  return &connections_;
}
inline const ::qaul::rpc::router::ConnectionEntry& ConnectionsUserEntry::_internal_connections(int index) const {
  return connections_.Get(index);
}
inline const ::qaul::rpc::router::ConnectionEntry& ConnectionsUserEntry::connections(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionsUserEntry.connections)
  return _internal_connections(index);
}
inline ::qaul::rpc::router::ConnectionEntry* ConnectionsUserEntry::_internal_add_connections() {
  return connections_.Add();
}
inline ::qaul::rpc::router::ConnectionEntry* ConnectionsUserEntry::add_connections() {
  ::qaul::rpc::router::ConnectionEntry* _add = _internal_add_connections();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.ConnectionsUserEntry.connections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::ConnectionEntry >&
ConnectionsUserEntry::connections() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.ConnectionsUserEntry.connections)
  return connections_;
}

// -------------------------------------------------------------------

// ConnectionEntry

// uint32 rtt = 1;
inline void ConnectionEntry::clear_rtt() {
  rtt_ = 0u;
}
inline uint32_t ConnectionEntry::_internal_rtt() const {
  return rtt_;
}
inline uint32_t ConnectionEntry::rtt() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionEntry.rtt)
  return _internal_rtt();
}
inline void ConnectionEntry::_internal_set_rtt(uint32_t value) {
  
  rtt_ = value;
}
inline void ConnectionEntry::set_rtt(uint32_t value) {
  _internal_set_rtt(value);
  // @@protoc_insertion_point(field_set:qaul.rpc.router.ConnectionEntry.rtt)
}

// uint32 hop_count = 2;
inline void ConnectionEntry::clear_hop_count() {
  hop_count_ = 0u;
}
inline uint32_t ConnectionEntry::_internal_hop_count() const {
  return hop_count_;
}
inline uint32_t ConnectionEntry::hop_count() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionEntry.hop_count)
  return _internal_hop_count();
}
inline void ConnectionEntry::_internal_set_hop_count(uint32_t value) {
  
  hop_count_ = value;
}
inline void ConnectionEntry::set_hop_count(uint32_t value) {
  _internal_set_hop_count(value);
  // @@protoc_insertion_point(field_set:qaul.rpc.router.ConnectionEntry.hop_count)
}

// bytes via = 3;
inline void ConnectionEntry::clear_via() {
  via_.ClearToEmpty();
}
inline const std::string& ConnectionEntry::via() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.ConnectionEntry.via)
  return _internal_via();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionEntry::set_via(ArgT0&& arg0, ArgT... args) {
 
 via_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.rpc.router.ConnectionEntry.via)
}
inline std::string* ConnectionEntry::mutable_via() {
  std::string* _s = _internal_mutable_via();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.ConnectionEntry.via)
  return _s;
}
inline const std::string& ConnectionEntry::_internal_via() const {
  return via_.Get();
}
inline void ConnectionEntry::_internal_set_via(const std::string& value) {
  
  via_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConnectionEntry::_internal_mutable_via() {
  
  return via_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConnectionEntry::release_via() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.ConnectionEntry.via)
  return via_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConnectionEntry::set_allocated_via(std::string* via) {
  if (via != nullptr) {
    
  } else {
    
  }
  via_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), via,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (via_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    via_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.rpc.router.ConnectionEntry.via)
}

// -------------------------------------------------------------------

// NeighboursRequest

// -------------------------------------------------------------------

// NeighboursList

// repeated .qaul.rpc.router.NeighboursEntry lan = 1;
inline int NeighboursList::_internal_lan_size() const {
  return lan_.size();
}
inline int NeighboursList::lan_size() const {
  return _internal_lan_size();
}
inline void NeighboursList::clear_lan() {
  lan_.Clear();
}
inline ::qaul::rpc::router::NeighboursEntry* NeighboursList::mutable_lan(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.NeighboursList.lan)
  return lan_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >*
NeighboursList::mutable_lan() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.NeighboursList.lan)
  return &lan_;
}
inline const ::qaul::rpc::router::NeighboursEntry& NeighboursList::_internal_lan(int index) const {
  return lan_.Get(index);
}
inline const ::qaul::rpc::router::NeighboursEntry& NeighboursList::lan(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.NeighboursList.lan)
  return _internal_lan(index);
}
inline ::qaul::rpc::router::NeighboursEntry* NeighboursList::_internal_add_lan() {
  return lan_.Add();
}
inline ::qaul::rpc::router::NeighboursEntry* NeighboursList::add_lan() {
  ::qaul::rpc::router::NeighboursEntry* _add = _internal_add_lan();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.NeighboursList.lan)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >&
NeighboursList::lan() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.NeighboursList.lan)
  return lan_;
}

// repeated .qaul.rpc.router.NeighboursEntry internet = 2;
inline int NeighboursList::_internal_internet_size() const {
  return internet_.size();
}
inline int NeighboursList::internet_size() const {
  return _internal_internet_size();
}
inline void NeighboursList::clear_internet() {
  internet_.Clear();
}
inline ::qaul::rpc::router::NeighboursEntry* NeighboursList::mutable_internet(int index) {
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.NeighboursList.internet)
  return internet_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >*
NeighboursList::mutable_internet() {
  // @@protoc_insertion_point(field_mutable_list:qaul.rpc.router.NeighboursList.internet)
  return &internet_;
}
inline const ::qaul::rpc::router::NeighboursEntry& NeighboursList::_internal_internet(int index) const {
  return internet_.Get(index);
}
inline const ::qaul::rpc::router::NeighboursEntry& NeighboursList::internet(int index) const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.NeighboursList.internet)
  return _internal_internet(index);
}
inline ::qaul::rpc::router::NeighboursEntry* NeighboursList::_internal_add_internet() {
  return internet_.Add();
}
inline ::qaul::rpc::router::NeighboursEntry* NeighboursList::add_internet() {
  ::qaul::rpc::router::NeighboursEntry* _add = _internal_add_internet();
  // @@protoc_insertion_point(field_add:qaul.rpc.router.NeighboursList.internet)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::qaul::rpc::router::NeighboursEntry >&
NeighboursList::internet() const {
  // @@protoc_insertion_point(field_list:qaul.rpc.router.NeighboursList.internet)
  return internet_;
}

// -------------------------------------------------------------------

// NeighboursEntry

// bytes node_id = 1;
inline void NeighboursEntry::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& NeighboursEntry::node_id() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.NeighboursEntry.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NeighboursEntry::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:qaul.rpc.router.NeighboursEntry.node_id)
}
inline std::string* NeighboursEntry::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:qaul.rpc.router.NeighboursEntry.node_id)
  return _s;
}
inline const std::string& NeighboursEntry::_internal_node_id() const {
  return node_id_.Get();
}
inline void NeighboursEntry::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NeighboursEntry::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NeighboursEntry::release_node_id() {
  // @@protoc_insertion_point(field_release:qaul.rpc.router.NeighboursEntry.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NeighboursEntry::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:qaul.rpc.router.NeighboursEntry.node_id)
}

// uint32 rtt = 2;
inline void NeighboursEntry::clear_rtt() {
  rtt_ = 0u;
}
inline uint32_t NeighboursEntry::_internal_rtt() const {
  return rtt_;
}
inline uint32_t NeighboursEntry::rtt() const {
  // @@protoc_insertion_point(field_get:qaul.rpc.router.NeighboursEntry.rtt)
  return _internal_rtt();
}
inline void NeighboursEntry::_internal_set_rtt(uint32_t value) {
  
  rtt_ = value;
}
inline void NeighboursEntry::set_rtt(uint32_t value) {
  _internal_set_rtt(value);
  // @@protoc_insertion_point(field_set:qaul.rpc.router.NeighboursEntry.rtt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace router
}  // namespace rpc
}  // namespace qaul

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::qaul::rpc::router::ConnectionModule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::qaul::rpc::router::ConnectionModule>() {
  return ::qaul::rpc::router::ConnectionModule_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_2frouter_2eproto
