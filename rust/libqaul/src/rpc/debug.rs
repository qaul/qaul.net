// Copyright (c) 2021 Open Community Project Association https://ocpa.ch
// This software is published under the AGPLv3 license.

//! # RPC Debug Messages
//!
//! Messages to debug libqaul

use super::Rpc;
use crate::storage::configuration::Configuration;
use crate::storage::Storage;
use crate::utilities::filelogger::FileLogger;
use prost::Message;

/// Import protobuf message definition generated by
/// the rust module prost-build.
pub mod proto {
    include!("qaul.rpc.debug.rs");
}

/// RPC Debugging Module
pub struct Debug {}

impl Debug {
    /// Process incoming RPC request messages for debug module
    pub fn rpc(data: Vec<u8>, _user_id: Vec<u8>) {
        match proto::Debug::decode(&data[..]) {
            Ok(debug) => {
                match debug.message {
                    Some(proto::debug::Message::HeartbeatRequest(_heartbeat_request)) => {
                        // create and return heartbeat message
                        let proto_message = proto::Debug {
                            message: Some(proto::debug::Message::HeartbeatResponse(
                                proto::HeartbeatResponse {},
                            )),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message
                            .encode(&mut buf)
                            .expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(
                            buf,
                            crate::rpc::proto::Modules::Debug.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    Some(proto::debug::Message::Panic(_panic)) => {
                        // panic
                        log::error!("Libqaul will panic");
                        panic!("Libqaul panics for debugging reasons");
                    }
                    Some(proto::debug::Message::LogToFile(log_to_file)) => {
                        if log_to_file.enable {
                            // start log
                            FileLogger::enable(true);
                            if Configuration::get_debug_log() == false {
                                Configuration::enable_debug_log(true);
                                Configuration::save();
                                log::info!("starting debug log..");
                            }
                        } else {
                            // stop log
                            if Configuration::get_debug_log() == true {
                                Configuration::enable_debug_log(false);
                                Configuration::save();
                                log::info!("stop debug log..");
                            }
                            FileLogger::enable(false);
                        }
                    }
                    Some(proto::debug::Message::StoragePathRequest(_storage_path_request)) => {
                        // create and return storage path response message
                        let path = Storage::get_path();
                        let proto_message = proto::Debug {
                            message: Some(proto::debug::Message::StoragePathResponse(
                                proto::StoragePathResponse { storage_path: path },
                            )),
                        };

                        // encode message
                        let mut buf = Vec::with_capacity(proto_message.encoded_len());
                        proto_message
                            .encode(&mut buf)
                            .expect("Vec<u8> provides capacity as needed");

                        // send message
                        Rpc::send_message(
                            buf,
                            crate::rpc::proto::Modules::Debug.into(),
                            "".to_string(),
                            Vec::new(),
                        );
                    }
                    _ => {
                        log::error!("Unhandled RPC Debug Message");
                    }
                }
            }
            Err(e) => {
                log::error!("{:?}", e);
            }
        }
    }
}
